{
    "summary": "This code contains three functions: voxelizing, rotating, and aligning grippers. It also includes functions for frame manipulation and obtaining point clouds from simulators. The code estimates normals, voxelizes, and returns point clouds and their normals using Open3D library.",
    "details": [
        {
            "comment": "This code defines three functions: `voxelize_pc`, `rotation_matrix_x`, and `align_gripper_z_with_normal`. The first function voxelizes a point cloud by down-sampling it, the second function calculates a rotation matrix for a rotation around the x-axis, and the third function aligns the gripper's z-axis with a given normal vector.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/grasping_utils.py\":0-29",
            "content": "import pybullet as p\nimport numpy as np\nfrom manipulation.utils import take_round_images_around_object, get_pc\nimport open3d as o3d\nfrom scipy.spatial.transform import Rotation as R\ndef voxelize_pc(pc, voxel_size=0.01):\n    pcd = o3d.geometry.PointCloud()\n    pcd.points = o3d.utility.Vector3dVector(pc)\n    try:\n        voxelized_pcd = pcd.voxel_down_sample(voxel_size)\n    except RuntimeError:\n        return None\n    voxelized_pc = np.asarray(voxelized_pcd.points)\n    return voxelized_pc\ndef rotation_matrix_x(theta):\n    \"\"\"Return a 3x3 rotation matrix for a rotation around the x-axis by angle theta.\"\"\"\n    return R.from_matrix(np.array([\n        [1, 0, 0],\n        [0, np.cos(theta), -np.sin(theta)],\n        [0, np.sin(theta), np.cos(theta)]\n    ]))\ndef align_gripper_z_with_normal(normal):\n    n_WS = normal\n    Gz = n_WS  # gripper z axis aligns with normal # TODO: check the object axis of the franka gripper\n    # make orthonormal y axis, aligned with world down\n    # y = np.array([0.0, 0.0, -1.0])\n    # or, make it horizontal"
        },
        {
            "comment": "Code in RoboGen/manipulation/grasping_utils.py defines functions to align gripper, create an orthonormal frame, and obtain point clouds with normals from a simulator.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/grasping_utils.py\":30-59",
            "content": "    y = np.array([0.0, -1, 0])\n    Gy = y - np.dot(y, Gz) * Gz\n    Gx = np.cross(Gy, Gz)\n    R_WG = R.from_matrix(np.vstack((Gx, Gy, Gz)).T)\n    return R_WG\ndef align_gripper_x_with_normal(normal):\n    n_WS = normal\n    Gx = n_WS  # gripper z axis aligns with normal # TODO: check the object axis of the franka gripper\n    # make orthonormal y axis, aligned with world down\n    # y = np.array([0.0, 0.0, -1.0])\n    # or, make it horizontal\n    y = np.array([0.0, -1, 0])\n    Gy = y - np.dot(y, Gx) * Gx\n    Gz = np.cross(Gx, Gy)\n    R_WG = R.from_matrix(np.vstack((Gx, Gy, Gz)).T)\n    return R_WG\ndef get_pc_and_normal(simulator, object_name):\n    camera_width=640\n    camera_height=480\n    rgbs, depths, view_camera_matrices, project_camera_matrices = \\\n        take_round_images_around_object(simulator, object_name, \n                                        return_camera_matrices=True, camera_height=camera_height, camera_width=camera_width, \n                                        only_object=True)\n    pcs = []\n    for depth, view_matrix, project_matrix in zip(depths, view_camera_matrices, project_camera_matrices):"
        },
        {
            "comment": "This code segment estimates point cloud normals, voxelizes the point cloud, and returns both the point cloud and its normals. It uses Open3D library for point cloud operations.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/grasping_utils.py\":60-73",
            "content": "        pc = get_pc(project_matrix, view_matrix, depth, camera_width, camera_height, mask_infinite=True)\n        pcs.append(pc)\n    pc = np.concatenate(pcs, axis=0)\n    pc = voxelize_pc(pc, voxel_size=0.0005) \n    ### get normals of the point cloud\n    pcd = o3d.geometry.PointCloud() \n    pcd.points = o3d.utility.Vector3dVector(pc)\n    pcd.estimate_normals()\n    normals = np.asarray(pcd.normals)\n    return pc, normals"
        }
    ]
}