{
    "summary": "The code defines a motion planning function for the RoboGen environment using OMPL, sets parameters and limits, and loops until a valid solution is found or 600 iterations are reached.",
    "details": [
        {
            "comment": "This code is importing necessary libraries and defining a function for motion planning using OMPL with Pybullet. It creates a robot object, sets the state, adds collision pairs if needed, initializes an interface, and sets the chosen planner before computing a collision-free IK solution.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/motion_planning_utils.py\":0-21",
            "content": "import numpy as np\nimport pybullet_ompl.pb_ompl as pb_ompl\nimport pybullet as p\nimport copy\ndef motion_planning(env, target_pos, target_orientation, planner=\"BITstar\", obstacles=[], allow_collision_links=[], panda_slider=True):\n    current_joint_angles = copy.deepcopy(env.robot.get_joint_angles(indices=env.robot.right_arm_joint_indices))\n    ompl_robot = pb_ompl.PbOMPLRobot(env.robot.body)\n    ompl_robot.set_state(current_joint_angles)\n    allow_collision_robot_link_pairs = []\n    if env.robot_name == \"sawyer\":\n        allow_collision_robot_link_pairs.append((5, 8))\n    if env.robot_name == 'fetch':\n        allow_collision_robot_link_pairs.append((3, 19))\n    pb_ompl_interface = pb_ompl.PbOMPL(ompl_robot, obstacles, allow_collision_links, \n                                       allow_collision_robot_link_pairs=allow_collision_robot_link_pairs)\n    pb_ompl_interface.set_planner(planner)\n    # first need to compute a collision-free IK solution\n    ik_lower_limits = env.robot.ik_lower_limits \n    ik_upper_limits = env.robot.ik_upper_limits "
        },
        {
            "comment": "The code is sampling target inverse kinematics (IK) positions and generating random IK rest poses within the given limits. It then calculates a new target joint angle using the calculateInverseKinematics function from a library, ensuring the joint angles remain within specified limits and are valid. The loop continues until a valid solution is found or exceeds 600 iterations.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/motion_planning_utils.py\":22-46",
            "content": "    print(\"ik_lower_limits: \", ik_lower_limits)\n    print(\"ik_upper_limits: \", ik_upper_limits)\n    ik_joint_ranges = ik_upper_limits - ik_lower_limits\n    it = 0\n    while True:\n        if it % 10 == 0:\n            print(\"sampling target ik it: \", it)\n        ik_rest_poses = np.random.uniform(ik_lower_limits, ik_upper_limits)\n        target_joint_angle = np.array(p.calculateInverseKinematics(\n            env.robot.body, env.robot.right_end_effector, \n            targetPosition=target_pos, targetOrientation=target_orientation, \n            lowerLimits=ik_lower_limits.tolist(), upperLimits=ik_upper_limits.tolist(), jointRanges=ik_joint_ranges.tolist(), \n            restPoses=ik_rest_poses.tolist(), \n            maxNumIterations=1000,\n            residualThreshold=1e-4\n        ))\n        if np.all(target_joint_angle >= ik_lower_limits) and np.all(target_joint_angle <= ik_upper_limits) \\\n                and pb_ompl_interface.is_state_valid(target_joint_angle):\n            break\n        it += 1\n        if it > 600:"
        },
        {
            "comment": "The code defines a function for motion planning joint angles in the RoboGen environment using OMPL. It first checks if a valid IK solution exists, then sets up the OMPL robot and interface, and finally plans a path based on the target joint angles provided. If no path is found, it returns False, otherwise it returns the result and the planned path.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/motion_planning_utils.py\":47-69",
            "content": "            ompl_robot.set_state(current_joint_angles)\n            print(\"failed to find a valid IK solution\")\n            return False, None\n    # then plan using ompl\n    assert len(target_joint_angle) == ompl_robot.num_dim\n    for idx in range(ompl_robot.num_dim):\n        print(\"joint: \", idx, \" lower limit: \", ompl_robot.joint_bounds[idx][0], \" upper limit: \", ompl_robot.joint_bounds[idx][1], \" target: \", target_joint_angle[idx])\n        assert (ompl_robot.joint_bounds[idx][0] <= target_joint_angle[idx]) & (target_joint_angle[idx] <= ompl_robot.joint_bounds[idx][1])\n    ompl_robot.set_state(current_joint_angles)\n    res, path = pb_ompl_interface.plan(target_joint_angle)\n    ompl_robot.set_state(current_joint_angles)\n    if not res:\n        print(\"motion planning failed to find a path\")\n    return res, path\ndef motion_planning_joint_angle(env, target_joint_angle, planner=\"BITstar\", obstacles=[], allow_collision_links=[], panda_slider=True):\n    ompl_robot = pb_ompl.PbOMPLRobot(env.robot.body)\n    pb_ompl_interface = pb_ompl.PbOMPL(ompl_robot, obstacles, allow_collision_links)"
        },
        {
            "comment": "This code sets the planner for OMPL interface, checks joint angle limits and targets, then plans using OMPL. If planning fails, it displays a failure message. Finally, it returns whether a path was found and the path itself.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/motion_planning_utils.py\":70-83",
            "content": "    pb_ompl_interface.set_planner(planner)\n    #  plan using ompl\n    assert len(target_joint_angle) == ompl_robot.num_dim\n    for idx in range(ompl_robot.num_dim):\n        print(\"joint: \", idx, \" lower limit: \", ompl_robot.joint_bounds[idx][0], \" upper limit: \", ompl_robot.joint_bounds[idx][1], \" target: \", target_joint_angle[idx])\n        assert (ompl_robot.joint_bounds[idx][0] <= target_joint_angle[idx]) & (target_joint_angle[idx] <= ompl_robot.joint_bounds[idx][1])\n    res, path = pb_ompl_interface.plan(target_joint_angle)\n    if not res:\n        print(\"motion planning failed to find a path\")\n    return res, path"
        }
    ]
}