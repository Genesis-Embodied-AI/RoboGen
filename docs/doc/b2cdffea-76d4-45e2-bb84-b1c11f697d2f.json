{
    "summary": "This code enables Franka Panda arm to perform household manipulation tasks by generating task descriptions, handling delays and extracting information for successful task execution.",
    "details": [
        {
            "comment": "This code imports necessary libraries and defines the task prompt for generating robot tasks using a simulator. The user will provide an articulated object with its articulation tree and semantics, and the goal is to imagine manipulation or interaction tasks for a robotic arm (Franka Panda) in household scenarios, excluding assembly/disassembly and cleaning tasks.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/gpt_4/prompts/prompt_manipulation.py\":0-15",
            "content": "import numpy as np\nimport copy\nimport time, datetime\nimport os\nimport json\nfrom objaverse_utils.utils import partnet_mobility_dict\nfrom gpt_4.prompts.utils import build_task_given_text, parse_task_response\nfrom gpt_4.query import query\ntask_user_contents = \"\"\"\nI will give you an articulated object, with its articulation tree and semantics. Your goal is to imagine some tasks that a robotic arm can perform with this articulated object in household scenarios. You can think of the robotic arm as a Franka Panda robot. The task will be built in a simulator for the robot to learn it. \nFocus on manipulation or interaction with the object itself. Sometimes the object will have functions, e.g., a microwave can be used to heat food, in these cases, feel free to include other objects that are needed for the task. \nPlease do not think of tasks that try to assemble or disassemble the object. Do not think of tasks that aim to clean the object or check its functionality. \nFor each task you imagined, please write in the following format: "
        },
        {
            "comment": "The code defines a task structure with properties such as the task name, description, required additional objects, links, joints, and an example input (oven articulation tree). Each link and joint has reasons for their necessity in completing the task.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/gpt_4/prompts/prompt_manipulation.py\":16-47",
            "content": "Task name: the name of the task.\nDescription: some basic descriptions of the tasks. \nAdditional Objects: Additional objects other than the provided articulated object required for completing the task. \nLinks: Links of the articulated objects that are required to perform the task. \n- Link 1: reasons why this link is needed for the task\n- Link 2: reasons why this link is needed for the task\n- \u2026\nJoints: Joints of the articulated objects that are required to perform the task. \n- Joint 1: reasons why this joint is needed for the task\n- Joint 2: reasons why this joint is needed for the task\n- \u2026\nExample Input: \n```Oven articulation tree\nlinks: \nbase\nlink_0\nlink_1\nlink_2\nlink_3\nlink_4\nlink_5\nlink_6\nlink_7\njoints: \njoint_name: joint_0 joint_type: revolute parent_link: link_7 child_link: link_0\njoint_name: joint_1 joint_type: continuous parent_link: link_7 child_link: link_1\njoint_name: joint_2 joint_type: continuous parent_link: link_7 child_link: link_2\njoint_name: joint_3 joint_type: continuous parent_link: link_7 child_link: link_3"
        },
        {
            "comment": "The code represents a list of joints and links for a robotic arm, with each line detailing a specific joint's properties (name, type, parent link, child link) and the corresponding link's description (semantics). These details are crucial for understanding the arm's structure and functionality.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/gpt_4/prompts/prompt_manipulation.py\":48-77",
            "content": "joint_name: joint_4 joint_type: continuous parent_link: link_7 child_link: link_4\njoint_name: joint_5 joint_type: continuous parent_link: link_7 child_link: link_5\njoint_name: joint_6 joint_type: continuous parent_link: link_7 child_link: link_6\njoint_name: joint_7 joint_type: fixed parent_link: base child_link: link_7\n```\n```Oven semantics\nlink_0 hinge door\nlink_1 hinge knob\nlink_2 hinge knob\nlink_3 hinge knob\nlink_4 hinge knob\nlink_5 hinge knob\nlink_6 hinge knob\nlink_7 heavy oven_body\n```\nExample output:\nTask Name: Open Oven Door\nDescription: The robotic arm will open the oven door.\nAdditional Objects: None\nLinks:\n- link_0: from the semantics, this is the door of the oven. The robot needs to approach this door in order to open it. \nJoints: \n- joint_0: from the articulation tree, this is the revolute joint that connects link_0. Therefore, the robot needs to actuate this joint for opening the door.\nTask Name: Adjust Oven Temperature\nDescription: The robotic arm will turn one of the oven's hinge knobs to set a desired temperature."
        },
        {
            "comment": "Code describes a robot task: heating a hamburger inside an oven. The robot opens the door, places the hamburger, and sets the desired temperature using a temperature knob. The code includes objects, links, and joints involved in the process.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/gpt_4/prompts/prompt_manipulation.py\":78-93",
            "content": "Additional Objects: None\nLinks:\n- link_1: the robot needs to approach link_1, which is assumed to be the temperature knob, to rotate it to set the temperature.\nJoints:\n- joint_1: joint_1 connects link_1 from the articulation tree. The robot needs to actuate it to rotate link_1 to the desired temperature.\nTask Name: Heat a hamburger Inside Oven \nDescription: The robot arm places a hamburger inside the oven, and sets the oven temperature to be appropriate for heating the hamburger.\nAdditional Objects: hamburger\nLinks:\n- link_0: link_0 is the oven door from the semantics. The robot needs to open the door in order to put the hamburger inside the oven.\nlink_1: the robot needs to approach link_1, which is the temperature knob, to rotate it to set the desired temperature.\nJoints:\n- joint_0: from the articulation tree, this is the revolute joint that connects link_0 (the door). Therefore, the robot needs to actuate this joint for opening the door.\n- joint_1: from the articulation tree, joint_1 connects lin"
        },
        {
            "comment": "The code snippet contains a function generate_task that generates task descriptions, involved objects, and joints based on an articulation tree and semantics file. The objective is to create precise object descriptions for robot manipulation tasks. It randomly samples objects from the given categories or paths for generation.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/gpt_4/prompts/prompt_manipulation.py\":93-112",
            "content": "k_1, which is the temperature knob. The robot needs to actuate it to rotate link_1 to the desired temperature.\nTask Name: Set Oven Timer\nDescription: The robot arm turns a timer knob to set cooking time for the food.\nAdditional Objects: None.\nLinks: \n- link_2: link_2 is assumed to be the knob for controlling the cooking time. The robot needs to approach link_2 to set the cooking time.\nJoints:\n- joint_2: from the articulation tree, joint_2 connects link_2. The robot needs to actuate joint_2 to rotate link_2 to the desired position, setting the oven timer.\nCan you do the same for the following object:\n\"\"\"\n# TODO: add another example where the ambiguous description is changed to be a precise description of the object. \ndef generate_task(object_category=None, object_path=None, existing_response=None, temperature_dict=None, \n                  model_dict=None, meta_path=\"generated_tasks\"):\n    # send the object articulation tree, semantics file and get task descriptions, invovled objects and joints\n    # randomly sample an object for generation. "
        },
        {
            "comment": "This code selects an object category and object ID from a predefined dictionary, reads the articulation tree and semantics for the selected object from files, and then fills in the task_user_contents with these data. This is done to generate a complete task description by combining the chosen object's information with the original task_user_contents. The code is part of a larger program that likely involves generating tasks or instructions for some kind of robot simulation or control system.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/gpt_4/prompts/prompt_manipulation.py\":114-138",
            "content": "    object_cetegories = list(partnet_mobility_dict.keys())\n    if object_category is None:\n        object_category = object_cetegories[np.random.randint(len(object_cetegories))]\n    if object_path is None:\n        possible_object_ids = partnet_mobility_dict[object_category]\n        object_path = possible_object_ids[np.random.randint(len(possible_object_ids))]\n    articulation_tree_path = f\"data/dataset/{object_path}/link_and_joint.txt\"\n    with open(articulation_tree_path, 'r') as f:\n        articulation_tree = f.readlines()\n    semantics = f\"data/dataset/{object_path}/semantics.txt\"\n    with open(semantics, 'r') as f:\n        semantics = f.readlines()\n    task_user_contents_filled = copy.deepcopy(task_user_contents)\n    articulation_tree_filled = \"\"\"\n```{} articulation tree\n{}\n```\"\"\".format(object_category, \"\".join(articulation_tree))\n    semantics_filled = \"\"\"\n```{} semantics\n{}\n```\"\"\".format(object_category, \"\".join(semantics))\n    task_user_contents_filled = task_user_contents_filled + articulation_tree_filled + semantics_filled"
        },
        {
            "comment": "This code checks if a response exists and generates or retrieves it. If no response exists, it creates a folder for the task, queries GPT-4 for a task generation, and saves the response in JSON format. If a response exists, it reads and prints the existing response.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/gpt_4/prompts/prompt_manipulation.py\":140-164",
            "content": "    if existing_response is None:\n        system = \"You are a helpful assistant.\"\n        ts = time.time()\n        time_string = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d-%H-%M-%S')\n        save_folder = \"data/{}/{}_{}_{}\".format(meta_path, object_category, object_path, time_string)\n        if not os.path.exists(save_folder + \"/gpt_response\"):\n            os.makedirs(save_folder + \"/gpt_response\")\n        save_path = \"{}/gpt_response/task_generation.json\".format(save_folder)\n        print(\"=\" * 50)\n        print(\"=\" * 20, \"generating task\", \"=\" * 20)\n        print(\"=\" * 50)\n        task_response = query(system, [task_user_contents_filled], [], save_path=save_path, debug=False, \n                              temperature=temperature_dict['task_generation'],\n                              model=model_dict['task_generation'])\n    else:\n        with open(existing_response, 'r') as f:\n            data = json.load(f)\n        task_response = data[\"res\"]\n        print(task_response)\n    ### generate task yaml config"
        },
        {
            "comment": "This function extracts task information from a response, creates configurations for each task using the build_task_given_text function, and stores the paths of all created configurations in a list. It also handles potential delays due to rate limits or API issues with time.sleep.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/gpt_4/prompts/prompt_manipulation.py\":165-183",
            "content": "    task_names, task_descriptions, additional_objects, links, joints = parse_task_response(task_response)\n    task_number = len(task_names)\n    print(\"task number: \", task_number)\n    all_config_paths = []\n    for task_idx in range(task_number):\n        if existing_response is None:\n            time.sleep(20)\n        task_name = task_names[task_idx]\n        task_description = task_descriptions[task_idx]\n        additional_object = additional_objects[task_idx]\n        involved_links = links[task_idx]\n        involved_joints = joints[task_idx]\n        config_path = build_task_given_text(object_category, task_name, task_description, additional_object, involved_links, involved_joints, \n                          articulation_tree_filled, semantics_filled, object_path, save_folder, temperature_dict, model_dict=model_dict)\n        all_config_paths.append(config_path)\n    return all_config_paths"
        }
    ]
}