{
    "summary": "\"save_numpy_as_gif\" function utilizes moviepy to save numpy array images as gif. The code defines a function that takes environment and save path, stores joint angles, and sets environment parameters based on the given state.",
    "details": [
        {
            "comment": "This function, \"save_numpy_as_gif\", takes a numpy array containing images and saves them as a gif using the moviepy library. It works with the current version of moviepy from Github and requires specifying the filename, frames per second (default: 20), and scaling factor for each image. The function ensures that the file has the .gif extension by appending it to the provided filename.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/cem_policy/utils.py\":0-33",
            "content": "import pickle\nfrom moviepy.editor import ImageSequenceClip\nimport os\nimport pybullet as p\ndef save_numpy_as_gif(array, filename, fps=20, scale=1.0):\n    \"\"\"Creates a gif given a stack of images using moviepy\n    Notes\n    -----\n    works with current Github version of moviepy (not the pip version)\n    https://github.com/Zulko/moviepy/commit/d4c9c37bc88261d8ed8b5d9b7c317d13b2cdf62e\n    Usage\n    -----\n    >>> X = randn(100, 64, 64)\n    >>> gif('test.gif', X)\n    Parameters\n    ----------\n    filename : string\n        The filename of the gif to write to\n    array : array_like\n        A numpy array that contains a sequence of images\n    fps : int\n        frames per second (default: 10)\n    scale : float\n        how much to rescale each image by (default: 1.0)\n    \"\"\"\n    # ensure that the file has the .gif extension\n    fname, _ = os.path.splitext(filename)\n    filename = fname + '.mp4'\n    # copy into the color dimension if the images are black and white\n    if array.ndim == 3:\n        array = array[..., np.newaxis] * np.ones(3)"
        },
        {
            "comment": "This code defines a function that takes an environment and save path as arguments, returns a Moviepy clip of image frames. The code also includes three dictionaries to store the names and joint angle values for each object in the environment. These dictionaries are populated by iterating over the objects and links in the environment, retrieving their corresponding joint angles and names using PyBullet physics engine functions.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/cem_policy/utils.py\":35-57",
            "content": "    # make the moviepy clip\n    # clip = ImageSequenceClip(list(array), fps=fps).resize(scale)\n    # clip.write_gif(filename, fps=fps)\n    clip = ImageSequenceClip(list(array), fps=fps)\n    clip.write_videofile(filename, bitrate='50000k', fps=fps, logger=None)\n    return clip\ndef save_env(env, save_path=None):\n    object_joint_angle_dicts = {}\n    object_joint_name_dicts = {}\n    object_link_name_dicts = {}\n    for obj_name, obj_id in env.urdf_ids.items():\n        num_links = p.getNumJoints(obj_id, physicsClientId=env.id)\n        object_joint_angle_dicts[obj_name] = []\n        object_joint_name_dicts[obj_name] = []\n        object_link_name_dicts[obj_name] = []\n        for link_idx in range(0, num_links):\n            joint_angle = p.getJointState(obj_id, link_idx, physicsClientId=env.id)[0]\n            object_joint_angle_dicts[obj_name].append(joint_angle)\n            joint_name = p.getJointInfo(obj_id, link_idx, physicsClientId=env.id)[1].decode('utf-8')\n            object_joint_name_dicts[obj_name].append(joint_name)"
        },
        {
            "comment": "This code is retrieving object joint information, link names, base positions, and base orientations from the environment (env). It then creates a state dictionary containing this information. If a save path is provided, it stores the state. The env contains urdf_ids for objects, urdf_paths, and urdf_scales. This code seems to be used in an environment with dynamic objects where state retrieval is necessary.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/cem_policy/utils.py\":58-81",
            "content": "            link_name = p.getJointInfo(obj_id, link_idx, physicsClientId=env.id)[12].decode('utf-8')\n            object_link_name_dicts[obj_name].append(link_name)\n    object_base_position = {}\n    for obj_name, obj_id in env.urdf_ids.items():\n        object_base_position[obj_name] = p.getBasePositionAndOrientation(obj_id, physicsClientId=env.id)[0]\n    object_base_orientation = {}\n    for obj_name, obj_id in env.urdf_ids.items():\n        object_base_orientation[obj_name] = p.getBasePositionAndOrientation(obj_id, physicsClientId=env.id)[1]\n    state = {\n        'object_joint_angle_dicts': object_joint_angle_dicts,\n        'object_joint_name_dicts': object_joint_name_dicts,\n        'object_link_name_dicts': object_link_name_dicts,\n        'object_base_position': object_base_position,\n        'object_base_orientation': object_base_orientation,     \n        'done': env.done,\n        'time_step': env.time_step,\n        'urdf_paths': env.urdf_paths,\n        'urdf_scales': env.urdf_scales,\n    }\n    if save_path is not None:"
        },
        {
            "comment": "The function at line 82 defines a method to save the current state of an environment in a pickle format, while the function at line 90 loads a previously saved state into the environment. The code resets the positions and orientations of objects within the environment based on the stored data, then resets the joint angles for each object. Finally, it updates the environment's \"done\" and \"time_step\" variables with the corresponding values from the saved state.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/cem_policy/utils.py\":82-109",
            "content": "        with open(save_path, 'wb') as f:\n            pickle.dump(state, f, pickle.HIGHEST_PROTOCOL)\n    return state\ndef load_env(env, load_path=None, state=None):\n    # print(\"state is: \", state)\n    if load_path is not None:\n        with open(load_path, 'rb') as f:\n            state = pickle.load(f)\n    ### set env to stored object position and orientation\n    for obj_name, obj_id in env.urdf_ids.items():\n        p.resetBasePositionAndOrientation(obj_id, state['object_base_position'][obj_name], state['object_base_orientation'][obj_name], physicsClientId=env.id)\n    ### set env to stored object joint angles\n    for obj_name, obj_id in env.urdf_ids.items():\n        num_links = p.getNumJoints(obj_id, physicsClientId=env.id)\n        for link_idx in range(0, num_links):\n            joint_angle = state['object_joint_angle_dicts'][obj_name][link_idx]\n            p.resetJointState(obj_id, link_idx, joint_angle, physicsClientId=env.id)\n    env.done = state['done']\n    env.time_step = state['time_step']\n    if \"urdf_paths\" in state:"
        },
        {
            "comment": "The code is setting environment parameters based on the given state. It assigns the \"urdf_paths\" from the state to the environment variable \"env.urdf_paths\", and if \"urdf_scales\" is present in the state, it assigns that value to the environment variable \"env.urdf_scales\". The function then returns the state.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/cem_policy/utils.py\":110-115",
            "content": "        env.urdf_paths = state[\"urdf_paths\"]\n    if \"urdf_scales\" in state:\n        env.urdf_scales = state[\"urdf_scales\"]\n    return state"
        }
    ]
}