{
    "summary": "The Agent class manages the robot's joint control, physics engine interaction, and state retrieval, enforcing joint limits, performing IK, and converting Euler angles to quaternions using PhysX library for manipulation tasks.",
    "details": [
        {
            "comment": "The Agent class initializes the base and body, sets lower and upper limits for joint angles, and defines the inverse kinematics (IK) joint names. The init function assigns the body, ID, and numpy random object to the agent instance. The control function adjusts joint motor control using position control mode. The get_joint_angles function retrieves the joint angles based on specified indices.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":0-28",
            "content": "import numpy as np\nimport pybullet as p\nclass Agent:\n    def __init__(self):\n        self.base = -1\n        self.body = None\n        self.lower_limits = None\n        self.upper_limits = None\n        self.ik_lower_limits = None\n        self.ik_upper_limits = None\n        self.ik_joint_names = None\n    def init(self, body, id, np_random, indices=None):\n        self.body = body\n        self.id = id\n        self.np_random = np_random\n        self.all_joint_indices = list(range(p.getNumJoints(body, physicsClientId=id)))\n        if indices != -1:\n            pass\n    def control(self, indices, target_angles, gains, forces):\n        if type(gains) in [int, float]:\n            gains = [gains]*len(indices)\n        if type(forces) in [int, float]:\n            forces = [forces]*len(indices)\n        p.setJointMotorControlArray(self.body, jointIndices=indices, controlMode=p.POSITION_CONTROL, targetPositions=target_angles, positionGains=gains, forces=forces, physicsClientId=self.id)\n    def get_joint_angles(self, indices=None):"
        },
        {
            "comment": "Method get_joint_angles returns the joint angles for specified indices. If no indices are provided, it defaults to all joints. Method get_joint_angles_dict converts the list of joint angles to a dictionary using zip function. Method get_pos_orient retrieves 3D position and orientation of a specific link on the body, returning as numpy array. The method get_velocity returns the velocity for specified link if it is the base, otherwise it does nothing.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":29-52",
            "content": "        if indices is None:\n            indices = self.all_joint_indices\n        elif not indices:\n            return []\n        robot_joint_states = p.getJointStates(self.body, jointIndices=indices, physicsClientId=self.id)\n        return np.array([x[0] for x in robot_joint_states])\n    def get_joint_angles_dict(self, indices=None):\n        return {j: a for j, a in zip(indices, self.get_joint_angles(indices))}\n    def get_pos_orient(self, link):\n        # Get the 3D position and orientation (4D quaternion) of a specific link on the body\n        if link == self.base:\n            pos, orient = p.getBasePositionAndOrientation(self.body, physicsClientId=self.id)\n        else:\n            pos, orient = p.getLinkState(self.body, link, physicsClientId=self.id)[:2]\n        return np.array(pos), np.array(orient)\n    def get_base_pos_orient(self):\n        return self.get_pos_orient(self.base)\n    def get_velocity(self, link):\n        if link == self.base:\n            return p.getBaseVelocity(self.body, physicsClientId=self.id)[0]"
        },
        {
            "comment": "This code snippet is from the RoboGen project, specifically the agent.py file. The function on line 53 returns the link state of an agent's body in terms of position (at index 6) using physics engine functions for forward kinematics and link velocity computations. There are three additional helper functions defined: get_euler, get_quaternion, and get_motor_joint_states. The first two convert between Euler angles and quaternions using the same physics client ID. The last function retrieves joint state information for non-fixed motor joints in the agent's body, filtering out fixed joints, and returns the positions of these joints in a list.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":53-67",
            "content": "        return p.getLinkState(self.body, link, computeForwardKinematics=True, computeLinkVelocity=True, physicsClientId=self.id)[6]\n    def get_euler(self, quaternion):\n        return np.array(p.getEulerFromQuaternion(np.array(quaternion), physicsClientId=self.id))\n    def get_quaternion(self, euler):\n        return np.array(p.getQuaternionFromEuler(np.array(euler), physicsClientId=self.id))\n    def get_motor_joint_states(self, joints=None):\n        # Get the position, velocity, and torque for nonfixed joint motors\n        joint_states = p.getJointStates(self.body, self.all_joint_indices if joints is None else joints, physicsClientId=self.id)\n        joint_infos = [p.getJointInfo(self.body, i, physicsClientId=self.id) for i in (self.all_joint_indices if joints is None else joints)]\n        motor_states = [j for j, i in zip(joint_states, joint_infos) if i[2] != p.JOINT_FIXED]\n        motor_indices = [i[0] for j, i in zip(joint_states, joint_infos) if i[2] != p.JOINT_FIXED]\n        motor_positions = [state[0] for state in motor_states]"
        },
        {
            "comment": "The code contains functions for manipulating robot joints. It retrieves motor states and torques, sets the base position and orientation of the robot, updates joint limits, and gets maximum force capacity for each joint. The code uses PyBullet physics engine (p) for interaction with the environment.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":68-90",
            "content": "        motor_velocities = [state[1] for state in motor_states]\n        motor_torques = [state[3] for state in motor_states]\n        return motor_indices, motor_positions, motor_velocities, motor_torques\n    def get_joint_max_force(self, indices=None):\n        if indices is None:\n            indices = self.all_joint_indices\n        joint_infos = [p.getJointInfo(self.body, i, physicsClientId=self.id) for i in indices]\n        return [j[10] for j in joint_infos]\n    def set_base_pos_orient(self, pos, orient):\n        p.resetBasePositionAndOrientation(self.body, pos, orient if len(orient) == 4 else self.get_quaternion(orient), physicsClientId=self.id)\n    def update_joint_limits(self, indices=None):\n        if indices is None:\n            indices = self.all_joint_indices\n        self.lower_limits = dict()\n        self.upper_limits = dict()\n        self.ik_lower_limits = []\n        self.ik_upper_limits = []\n        self.ik_joint_names = []\n        for j in indices:\n            joint_info = p.getJointInfo(self.body, j, physicsClientId=self.id)"
        },
        {
            "comment": "This code sets joint limits and prepares them for inverse kinematics (IK) calculations. It ensures that all joints have appropriate lower and upper limits, and separates fixed joints from non-fixed ones. If a joint is fixed, it defines special limit values for IK calculations. The code then appends the joint information to lists for joint names, lower limits, and upper limits. Finally, it converts the ik_lower_limits list into a numpy array.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":91-109",
            "content": "            joint_name = joint_info[1]\n            joint_type = joint_info[2]\n            lower_limit = joint_info[8]\n            upper_limit = joint_info[9]\n            if lower_limit == 0 and upper_limit == -1:\n                lower_limit = -1e10\n                upper_limit = 1e10\n                if joint_type != p.JOINT_FIXED:\n                    # NOTE: IK only works on non fixed joints, so we build special joint limit lists for IK\n                    self.ik_lower_limits.append(-2*np.pi)\n                    self.ik_upper_limits.append(2*np.pi)\n                    self.ik_joint_names.append([len(self.ik_joint_names)] + list(joint_info[:2]))\n            elif joint_type != p.JOINT_FIXED:\n                self.ik_lower_limits.append(lower_limit)\n                self.ik_upper_limits.append(upper_limit)\n                self.ik_joint_names.append([len(self.ik_joint_names)] + list(joint_info[:2]))\n            self.lower_limits[j] = lower_limit\n            self.upper_limits[j] = upper_limit\n        self.ik_lower_limits = np.array(self.ik_lower_limits)"
        },
        {
            "comment": "The code defines a class with methods for enforcing joint limits and performing inverse kinematics (IK). The `enforce_joint_limits` method checks joint angles against lower and upper limits, while the `ik` method solves IK equations to find suitable joint angles for a given target position and orientation. The `get_quaternion` method converts Euler angles to quaternions.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":110-126",
            "content": "        self.ik_upper_limits = np.array(self.ik_upper_limits)\n    def enforce_joint_limits(self, indices=None):\n        if indices is None:\n            indices = self.all_joint_indices\n        joint_angles = self.get_joint_angles_dict(indices)\n        if self.lower_limits is None or len(indices) > len(self.lower_limits):\n            self.update_joint_limits()\n        for j in indices:\n            if joint_angles[j] < self.lower_limits[j]:\n                p.resetJointState(self.body, jointIndex=j, targetValue=self.lower_limits[j], targetVelocity=0, physicsClientId=self.id)\n            elif joint_angles[j] > self.upper_limits[j]:\n                p.resetJointState(self.body, jointIndex=j, targetValue=self.upper_limits[j], targetVelocity=0, physicsClientId=self.id)\n    def ik(self, target_joint, target_pos, target_orient, ik_indices, max_iterations=1000, use_current_as_rest=True):\n        if target_orient is not None and len(target_orient) < 4:\n            target_orient = self.get_quaternion(target_orient)"
        },
        {
            "comment": "This code checks if the current joint states should be used as the rest pose for calculating inverse kinematics. If so, it gets the motor joint states and converts them into a list. It also sets up the lower and upper limits for joint movement and calculates the joint ranges. If the target orientation is not None, it calls the calculateInverseKinematics function to find the joint positions for either using the rest pose or the current joint states depending on the condition.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":127-145",
            "content": "        if use_current_as_rest:\n            ik_rest_poses = np.array(self.get_motor_joint_states()[1]).tolist()\n        ik_lower_limits = self.ik_lower_limits \n        ik_upper_limits = self.ik_upper_limits \n        ik_joint_ranges = ik_upper_limits - ik_lower_limits\n        if target_orient is not None:\n            if use_current_as_rest:\n                ik_joint_poses = np.array(p.calculateInverseKinematics(\n                    self.body, target_joint, \n                    targetPosition=target_pos, targetOrientation=target_orient, \n                    lowerLimits=ik_lower_limits.tolist(), upperLimits=ik_upper_limits.tolist(), jointRanges=ik_joint_ranges.tolist(), \n                    restPoses=ik_rest_poses, \n                    maxNumIterations=max_iterations, \n                    residualThreshold=1e-4,\n                    physicsClientId=self.id))\n            else:\n                ik_joint_poses = np.array(p.calculateInverseKinematics(self.body, target_joint, targetPosition=target_pos, targetOrientation=target_orient, physicsClientId=self.id))"
        },
        {
            "comment": "This code snippet appears to be part of a larger program that uses the Python interface for PhysX (p) library. It includes functions for calculating inverse kinematics, printing joint information, and setting joint angles in a robot's body. The functions use arrays and iterate through the joint indices for manipulation tasks.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":146-165",
            "content": "        else:\n            if use_current_as_rest:\n                ik_joint_poses = np.array(p.calculateInverseKinematics(self.body, target_joint, targetPosition=target_pos, restPoses=ik_rest_poses, maxNumIterations=max_iterations, physicsClientId=self.id))\n            else:\n                ik_joint_poses = np.array(p.calculateInverseKinematics(self.body, target_joint, targetPosition=target_pos, maxNumIterations=max_iterations, physicsClientId=self.id))            \n        return ik_joint_poses[ik_indices]\n    def print_joint_info(self, show_fixed=True):\n        joint_names = []\n        for j in self.all_joint_indices:\n            info = p.getJointInfo(self.body, j, physicsClientId=self.id)\n            if show_fixed or info[2] != p.JOINT_FIXED:\n                print(info)\n                joint_names.append((j, info[1]))\n        print(joint_names)\n    def set_joint_angles(self, indices, angles, use_limits=True, velocities=0):\n        for i, (j, a) in enumerate(zip(indices, angles)):\n            p.resetJ"
        },
        {
            "comment": "Sets the state of a robot's joint based on input parameters, taking into account limits and velocities if applicable.",
            "location": "\"/media/root/Prima/works/RoboGen/docs/src/manipulation/agent.py\":165-165",
            "content": "ointState(self.body, jointIndex=j, targetValue=min(max(a, self.lower_limits[j]), self.upper_limits[j]) if use_limits else a, targetVelocity=velocities if type(velocities) in [int, float] else velocities[i], physicsClientId=self.id)"
        }
    ]
}